{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PCAM-24: A Phase-Centric Action Model","text":"<p>For Deterministic Interactive Simulation</p> <p>Abstract</p> <p>This paper introduces PCAM-24, a simulation model in which discrete phase\u2014rather than continuous time\u2014is the authoritative coordinate for action progression. By elevating phase to a first-class primitive, PCAM-24 eliminates timing inference between subsystems, simplifies deterministic networking, and provides a shared semantic language for animation, combat, and AI.</p>"},{"location":"#1-introduction","title":"1. Introduction","text":"<p>Modern interactive simulations\u2014especially games\u2014coordinate multiple subsystems that each operate on their own notion of time. Animation advances clip time, combat evaluates frame-based windows, and networking reconciles wall-clock deltas. This fragmentation produces: * Desynchronization between animation and gameplay * Brittle timing logic (floats/frames) * Ambiguous interaction adjudication</p> <p>PCAM-24 proposes a different foundation: replace time as the primary semantic coordinate with discrete phase. Rather than asking \"when did something happen?\", PCAM-24 asks \"what stage of the action is occurring?\"</p>"},{"location":"#2-core-concept","title":"2. Core Concept","text":""},{"location":"#21-phase-space","title":"2.1 Phase Space","text":"<p>PCAM-24 defines a fixed, cyclic phase space:</p> <p>5243Phase \\in \\mathbb{Z}_{24} = {0,1,\\dots,23}5243</p> <p>Phase advances discretely and wraps modulo 24.</p> <p>The choice of 24 phases reflects a balance between expressive resolution and cognitive tractability. It provides sufficient granularity to model nuanced action stages while remaining small enough to reason about as a complete cycle.</p>"},{"location":"#22-actions","title":"2.2 Actions","text":"<p>An action is the atomic unit of interactive intent. Each action owns: * A current phase value * A phase progression rule * A set of named phase windows * Deterministic transition rules</p>"},{"location":"#3-phase-windows-and-semantics","title":"3. Phase Windows and Semantics","text":"<p>A phase window is a named subset of the phase space  \\subseteq \\mathbb{Z}_{24}$. * ACTIVE: Phases where an attack deals damage. * INVULN: Phases where damage is negated. * PARRY_PERFECT: Phases where a parry succeeds.</p>"},{"location":"#4-phase-authority-the-axioms","title":"4. Phase Authority (The Axioms)","text":"<p>PCAM-24 enforces several non-negotiable axioms:</p> <ol> <li>Phase is Authoritative: It is the sole coordinate for ordering and adjudication.</li> <li>Discrete Semantics: All logic must be expressible as phase membership.</li> <li>Monotonic Progression: No rewinds. Corrections occur by snapping phase.</li> <li>Subsystem Subscription: Animation/Audio observe phase but do not drive it.</li> <li>Interaction by Phase: Cross-entity interactions are resolved by phase rules, not wall-clock time.</li> </ol>"},{"location":"#5-action-lifecycles","title":"5. Action Lifecycles","text":"<ul> <li>Impulse: Progress once and terminate (e.g., Melee Attack).</li> <li>Sustained: Loop while input is held (e.g., Block).</li> <li>Reactive: Narrow success window (e.g., Parry).</li> <li>Evasive: Invulnerability window + movement (e.g., Dodge).</li> </ul>"},{"location":"#6-transitions-buffering","title":"6. Transitions &amp; Buffering","text":"<ul> <li>Cancels are allowed only within defined windows.</li> <li>Inputs are buffered and consumed deterministically.</li> <li>Priority rules resolve simultaneous transition eligibility.</li> </ul>"},{"location":"#7-interaction-adjudication","title":"7. Interaction Adjudication","text":"<p>PCAM-24 requires explicit precedence for contested interactions: 1.  Evasion (e.g., INVULN) 2.  Perfect Defense 3.  Mitigating Defense 4.  Hit</p>"},{"location":"#8-networking-and-determinism","title":"8. Networking and Determinism","text":"<p>PCAM-24 is inherently network-friendly. * Replication: Transmits Action ID + Phase. * Prediction: Clients predict by advancing phase. * Reconciliation: Snap to authoritative phase (no complex time rewinding).</p>"},{"location":"#10-benefits","title":"10. Benefits","text":"<p>Why use PCAM-24?</p> <ul> <li>Consistency: All systems share a single semantic clock.</li> <li>Determinism: Eliminates floating-point drift.</li> <li>Explainability: Bugs are inspectable state, not vague timing artifacts.</li> <li>Authorability: Designers reason in stages, not milliseconds.</li> </ul>"},{"location":"#12-conclusion","title":"12. Conclusion","text":"<p>PCAM-24 reframes interactive simulation timing from a question of when to a question of what stage. It is not an optimization of existing timing systems. It is a replacement of their underlying assumption.</p>"},{"location":"LICENSE/","title":"License","text":"<p>Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International</p> <p>By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.</p>"},{"location":"LICENSE/#full-license-text-httpscreativecommonsorglicensesby-nc-nd40legalcode","title":"Full License Text: https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode","text":"<p>SUMMARY OF RIGHTS:</p> <ol> <li> <p>You are free to share, copy, and redistribute the material in any medium or format.</p> </li> <li> <p>Under the following terms:</p> </li> <li>Attribution: You must give appropriate credit to Greyforge Labs.</li> <li>NonCommercial: You may not use the material for commercial purposes.</li> <li> <p>NoDerivatives: If you remix, transform, or build upon the material, you may not distribute the modified material.</p> </li> <li> <p>No additional restrictions: You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</p> </li> </ol> <p>COPYRIGHT 2026 GREYFORGE LABS</p>"},{"location":"faq/","title":"PCAM-24 FAQ","text":"<p>This FAQ addresses common questions, misunderstandings, and objections about PCAM-24. If you are skeptical, that is expected \u2014 this document exists to answer those concerns directly.</p>"},{"location":"faq/#is-pcam-24-just-frame-data-with-a-new-name","title":"Is PCAM-24 just frame data with a new name?","text":"<p>No.</p> <p>Frame data is tied to: - render rate - animation playback speed - platform performance</p> <p>PCAM-24 phase: - is engine-agnostic - is independent of frame rate - remains stable under latency - is authoritative for simulation</p> <p>Frames describe presentation. Phase describes semantic stage.</p>"},{"location":"faq/#why-not-just-use-animation-events-or-notifies","title":"Why not just use animation events or notifies?","text":"<p>Animation events: - are clip-specific - break under blending - assume animation is authoritative - do not generalize across systems</p> <p>PCAM-24 treats animation as a derived view. Gameplay logic never depends on animation timing.</p> <p>If animation changes, gameplay does not break.</p>"},{"location":"faq/#why-24-phases-specifically","title":"Why 24 phases specifically?","text":"<p>24 provides: - sufficient resolution for nuanced actions - clean divisibility (2, 3, 4, 6, 8, 12) - a full action cycle without excessive granularity - cognitive tractability for designers</p> <p>PCAM-24 is not about numerology. The principle is discrete, bounded, semantic phase.</p> <p>Other phase counts are possible, but 24 is a practical sweet spot.</p>"},{"location":"faq/#does-pcam-24-require-a-fixed-timestep","title":"Does PCAM-24 require a fixed timestep?","text":"<p>No.</p> <p>PCAM-24 requires discrete phase advancement, not a specific timestep.</p> <p>Phase can advance: - one step per tick - multiple steps per tick - via fixed-point accumulators</p> <p>The only requirement is that phase advancement is deterministic and integer-based.</p>"},{"location":"faq/#is-this-just-a-state-machine","title":"Is this just a state machine?","text":"<p>PCAM-24 is not a traditional state machine.</p> <p>State machines: - represent discrete modes - often hide timing inside transitions - do not encode progression semantics explicitly</p> <p>PCAM-24: - encodes progression as phase - makes stage explicit and inspectable - allows continuous movement through semantic space</p> <p>Actions are processes, not states.</p>"},{"location":"faq/#how-does-this-work-with-physics","title":"How does this work with physics?","text":"<p>PCAM-24 does not replace physics.</p> <p>Physics continues to use: - continuous time - floating-point integration</p> <p>PCAM-24 defines authoritative interaction semantics: - when damage applies - when invulnerability applies - when cancels are allowed</p> <p>Physics answers where things are. Phase answers what stage they are in.</p>"},{"location":"faq/#is-pcam-24-only-for-melee-combat","title":"Is PCAM-24 only for melee combat?","text":"<p>No.</p> <p>PCAM-24 applies to: - ranged attacks - spell casting - ability cooldowns - AI decision windows - movement abilities - interactive simulations beyond games</p> <p>Any system where actions have meaningful stages can benefit.</p>"},{"location":"faq/#how-does-pcam-24-help-multiplayer","title":"How does PCAM-24 help multiplayer?","text":"<p>PCAM-24 replicates: - action identity - phase - start-captured parameters</p> <p>It does not replicate: - elapsed time - animation state - frame counts</p> <p>This makes reconciliation: - simpler - explainable - consistent across clients</p> <p>Disagreements can be reasoned about in phase units.</p>"},{"location":"faq/#what-about-latency-and-fairness","title":"What about latency and fairness?","text":"<p>Latency still exists.</p> <p>PCAM-24 improves fairness by: - making adjudication deterministic - allowing bounded forgiveness in phase units - avoiding ambiguous timing inference</p> <p>Instead of \u201clag ate my parry,\u201d you get: - \u201cthe server resolved phase 9, not phase 10\u201d</p> <p>That distinction matters.</p>"},{"location":"faq/#does-pcam-24-eliminate-skill-timing","title":"Does PCAM-24 eliminate skill timing?","text":"<p>No.</p> <p>PCAM-24 makes skill timing explicit.</p> <p>Skill expression comes from: - window size - window placement - recovery length - cancel availability</p> <p>Not from hidden frame math.</p>"},{"location":"faq/#is-pcam-24-overkill-for-simple-games","title":"Is PCAM-24 overkill for simple games?","text":"<p>Possibly.</p> <p>If your game: - has no contested interactions - is single-player only - does not care about determinism or explainability</p> <p>Then PCAM-24 may be unnecessary.</p> <p>PCAM-24 shines as complexity grows.</p>"},{"location":"faq/#can-pcam-24-coexist-with-existing-systems","title":"Can PCAM-24 coexist with existing systems?","text":"<p>Yes.</p> <p>PCAM-24 defines authority, not presentation.</p> <p>It can coexist with: - existing animation systems - physics engines - rendering pipelines</p> <p>The key requirement is respecting phase as the source of truth.</p>"},{"location":"faq/#is-pcam-24-production-proven","title":"Is PCAM-24 production-proven?","text":"<p>PCAM-24 is a formalized model, not a shipping engine.</p> <p>However, many successful systems implicitly approximate phase-based thinking. PCAM-24 makes those semantics explicit, unified, and inspectable.</p>"},{"location":"faq/#what-is-the-relationship-between-pcam-24-and-ag-24","title":"What is the relationship between PCAM-24 and AG-24?","text":"<p>PCAM-24 defines: - the semantic rules - the guarantees - the philosophy</p> <p>AG-24 is an execution substrate designed to enforce PCAM-24.</p> <p>PCAM-24 comes first.</p>"},{"location":"faq/#final-clarification","title":"Final clarification","text":"<p>PCAM-24 does not claim: - to replace all timing systems - to eliminate physics - to be the only valid model</p> <p>It claims that for action semantics, stage matters more than time.</p>"},{"location":"guide/","title":"PCAM-24: A Designer\u2019s Guide","text":"<p>To Phase-Based Actions</p> <p>One idea to remember</p> <p>Actions don\u2019t happen over time. Actions move through stages.</p> <p>PCAM-24 gives you a clear, shared way to describe those stages\u2014so animation, combat, AI, and player input all agree on what is happening right now.</p>"},{"location":"guide/#1-what-problem-pcam-24-solves","title":"1. What problem PCAM-24 solves","text":"<p>In designer terms</p> <p>If you\u2019ve ever dealt with: * \"The animation hit, but the damage didn\u2019t\" * \"The parry felt right but failed online\" * \"This move is balanced at 60 FPS but broken at 120\" * \"Which frame does the hitbox turn on again?\"</p> <p>PCAM-24 exists to remove those problems at the design level, not as a late technical fix.</p>"},{"location":"guide/#2-phase-replaces-time","title":"2. Phase replaces time","text":"<p>How to think differently</p> <p>In PCAM-24, every action moves through 24 phases, numbered 0\u201323.</p> Do NOT think in... DO think in... Seconds Stages of the action Frames Wind-up / Commitment Normalized Time Impact / Recovery"},{"location":"guide/#3-phase-windows","title":"3. Phase windows","text":"<p>Your main design tool</p> <p>A Window is just a named range of phases.</p> <p>Example: Light Attack</p> Window Name Phases Meaning Anticipation 0\u20135 Player commits Commit 6\u20139 Cannot cancel Active 10\u201313 Attack can hit Recovery 14\u201321 Vulnerable Reset 22\u201323 Combo allowed <p>No timers. No frame math. No \"magic numbers\".</p>"},{"location":"guide/#4-what-you-author-and-what-you-dont","title":"4. What you author (and what you don\u2019t)","text":"<p>You Author: * Phase windows * Which actions can cancel into others * Where hits, invulnerability, parries, and combos live * How risky or safe an action feels</p> <p>You Do NOT Author: * Animation frame numbers * Millisecond windows * Per-FPS tuning * Separate logic for online vs offline</p>"},{"location":"guide/#5-animation-becomes-a-follower","title":"5. Animation becomes a follower","text":"<p>Animation does not decide gameplay. Instead, Animation reads the current phase.</p> <ul> <li>If the attack looks like it hits, it is in the  window.</li> <li>There is no \"visual lie.\"</li> </ul> <p> The Shift</p> <p>You stop asking: \"Which animation frame is the hit?\"</p> <p>You start asking: \"Which phase is dangerous?\"</p>"},{"location":"guide/#6-dodge-parry-and-block","title":"6. Dodge, Parry, and Block","text":"<p>Why this feels fair</p>"},{"location":"guide/#dodge","title":"Dodge","text":"<p>Invulnerability is a phase window. * Example: Phases 7\u201312 are . * If a hit occurs outside that window, it always lands.</p>"},{"location":"guide/#parry","title":"Parry","text":"<p>Perfect parry is a very small phase window. * Example: Phases 4\u20136 are . * Late parry may block instead of parry.</p>"},{"location":"guide/#block","title":"Block","text":"<p>Block strength can change by phase. Holding block too long can naturally weaken it as the phase loops.</p>"},{"location":"guide/#7-cancels-and-combos","title":"7. Cancels and Combos","text":"<p>Clean and readable</p> <p>Instead of \"combo window is frames 38\u201341\", you define Chain Windows.</p> <ul> <li>Example: Combo allowed only during phases 22\u201323.</li> <li>Attack input buffered earlier will fire automatically there.</li> </ul> <p>This makes combos consistent, latency-safe, and easy to rebalance.</p>"},{"location":"guide/#8-why-this-helps-ai-design","title":"8. Why this helps AI design","text":"<p>AI doesn\u2019t guess anymore. It sees: 1. Opponent Action 2. Opponent Phase 3. Opponent Window</p> <p>So it can dodge only during  windows or punish only during .</p>"},{"location":"guide/#9-multiplayer-feels-better","title":"9. Multiplayer feels better","text":"<p>Without you designing \"for netcode\"</p> <p>Because phase is authoritative: * Online and offline behave the same. * Hits are decided by phase, not packet timing. * Disagreements are explainable (\"you were in phase 9, not 10\").</p>"},{"location":"guide/#10-how-you-tune-difficulty","title":"10. How you tune difficulty","text":"<p>You adjust Window Sizes and Window Positions.</p> <ul> <li>Make a move safer \\(\\to\\) Shorten  window.</li> <li>Make parry harder \\(\\to\\) Shrink  window.</li> <li>Make combat faster \\(\\to\\) Shift  earlier.</li> <li>Make stamina matter \\(\\to\\) Reduce  windows.</li> </ul>"},{"location":"guide/#11-debugging-becomes-visual","title":"11. Debugging becomes visual","text":"<p>A PCAM-24 game can show you exactly why a hit failed. * Instead of \"It feels off sometimes...\" * You get \"This window is too short\" or \"This cancel overlaps too much.\"</p>"},{"location":"guide/#12-mental-model-summary","title":"12. Mental Model Summary","text":"<p>Keep This</p> <ul> <li>Phase = Where the action is</li> <li>Windows = What the action can do</li> <li>Time = Irrelevant to gameplay authority</li> <li>Animation = Presentation</li> <li>Phase = Truth</li> </ul>"},{"location":"guide/#13-what-pcam-24-is-not","title":"13. What PCAM-24 is not","text":"<p>To avoid confusion, PCAM-24 is not: * A new animation system * A timing tweak * A combat gimmick * A fighting-game-only thing</p> <p>It is a shared language for action stages.</p>"},{"location":"guide/#14-why-this-is-a-design-upgrade","title":"14. Why this is a design upgrade","text":"<p>PCAM-24 lets designers reason about gameplay in human terms and avoid fragile timing logic.</p> <p>You stop fighting the engine. You start shaping actions.</p>"},{"location":"minimal-example/","title":"Minimal Example: One Action, One Interaction","text":"<p>This document demonstrates PCAM-24 using the smallest possible complete example: - one attack - one dodge - one interaction outcome</p> <p>No engine assumptions. No animation details. Just the core logic.</p>"},{"location":"minimal-example/#the-scenario","title":"The Scenario","text":"<ul> <li>An attacker performs a light melee attack.</li> <li>A defender attempts a dodge.</li> <li>We determine whether the hit lands or is avoided.</li> </ul> <p>Everything is decided using phase, not time.</p>"},{"location":"minimal-example/#step-1-define-the-phase-space","title":"Step 1: Define the Phase Space","text":"<p>PCAM-24 uses a fixed phase cycle:</p> <p>cat &lt;&lt; 'EOF' &gt; docs/minimal-example.md</p>"},{"location":"minimal-example/#minimal-example-one-action-one-interaction_1","title":"Minimal Example: One Action, One Interaction","text":"<p>This document demonstrates PCAM-24 using the smallest complete example possible: - one attack - one dodge - one interaction outcome</p> <p>No engine assumptions. No animation details. Just the core logic.</p>"},{"location":"minimal-example/#the-scenario_1","title":"The Scenario","text":"<ul> <li>An attacker performs a light melee attack.</li> <li>A defender attempts a dodge.</li> <li>We determine whether the hit lands or is avoided.</li> </ul> <p>Everything is decided using phase, not time.</p>"},{"location":"minimal-example/#step-1-define-the-phase-space_1","title":"Step 1: Define the Phase Space","text":"<p>PCAM-24 uses a fixed phase cycle:</p> <p>Phase \u2208 {0, 1, 2, ..., 23}</p> <p>Phase advances discretely and wraps modulo 24.</p>"},{"location":"minimal-example/#step-2-define-the-attack-action","title":"Step 2: Define the Attack Action","text":"<p>Action: MELEE_LIGHT</p> <p>Window definitions:</p> <p>ANTICIPATION: phases 0\u20135 COMMIT: phases 6\u20139 ACTIVE: phases 10\u201313 RECOVERY: phases 14\u201321 RESET: phases 22\u201323  </p> <p>The only phases where damage is possible are phases 10\u201313.</p>"},{"location":"minimal-example/#step-3-define-the-dodge-action","title":"Step 3: Define the Dodge Action","text":"<p>Action: DODGE_ROLL</p> <p>Window definitions:</p> <p>STARTUP: phases 0\u20133 INVULN: phases 7\u201312 RECOVERY: phases 13\u201323  </p> <p>The only phases where damage is negated are phases 7\u201312.</p>"},{"location":"minimal-example/#step-4-advance-the-simulation","title":"Step 4: Advance the Simulation","text":"<p>Each simulation tick:</p> <p>action.phase = (action.phase + 1) mod 24</p> <p>There is no notion of: - seconds - frames - animation time</p> <p>Only phase progression.</p>"},{"location":"minimal-example/#step-5-interaction-resolution","title":"Step 5: Interaction Resolution","text":"<p>When the attacker is in range, the outcome is resolved as follows:</p> <p>if defender.action == DODGE and defender.phase \u2208 INVULN:     result = DODGED else if attacker.phase \u2208 ACTIVE:     result = HIT else:     result = NO_HIT</p> <p>That is the complete adjudication logic.</p>"},{"location":"minimal-example/#step-6-example-outcomes","title":"Step 6: Example Outcomes","text":"<p>Case A \u2014 Dodge succeeds Attacker phase = 11 (ACTIVE) Defender phase = 9 (INVULN)  </p> <p>Result: DODGED</p> <p>Case B \u2014 Dodge fails Attacker phase = 11 (ACTIVE) Defender phase = 14 (RECOVERY)  </p> <p>Result: HIT</p> <p>Case C \u2014 Attack cannot hit Attacker phase = 8 (COMMIT)  </p> <p>Result: NO_HIT</p>"},{"location":"minimal-example/#step-7-what-is-not-used","title":"Step 7: What Is Not Used","text":"<p>This example deliberately avoids: - animation frames - normalized clip time - floating-point comparisons - timers or cooldowns - frame rate assumptions - network arrival order</p> <p>Everything is decided by phase window membership.</p>"},{"location":"minimal-example/#step-8-derived-views","title":"Step 8: Derived Views","text":"<p>Animation, VFX, and audio are derived from phase:</p> <p>pose = animation.sample(phase)</p> <p>They never affect gameplay outcomes.</p> <p>This guarantees: - visual correctness - no \u201clying\u201d animations - consistent offline and online behavior</p>"},{"location":"minimal-example/#key-takeaway","title":"Key Takeaway","text":"<p>PCAM-24 reduces action logic to: - discrete phase - explicit semantic windows - deterministic rules</p> <p>This minimal example scales directly to: - parries - blocks - combos - AI reactions - multiplayer reconciliation</p> <p>Without changing the core idea.</p> <p>If you understand this example, you understand PCAM-24.</p>"},{"location":"spec/","title":"PCAM-24 Formal Specification v1.0","text":"<p>Status: Stable Scope: Normative Audience: Engine programmers, technical designers, system architects</p> <p>This document defines the Phase-Centric Action Model (PCAM-24) in precise, implementation-independent terms. All conforming systems MUST adhere to the requirements stated herein.</p>"},{"location":"spec/#1-definitions","title":"1. Definitions","text":""},{"location":"spec/#11-phase","title":"1.1 Phase","text":"<p>A phase is a discrete integer representing an action\u2019s position within its lifecycle.</p> <ul> <li>Phase \u2208 \u2124\u208d\u2082\u2084\u208e = {0, 1, \u2026, 23}</li> <li>Phase arithmetic MUST be performed modulo 24</li> <li>Phase values MUST be integer</li> <li>Fractional or continuous phase values are forbidden</li> </ul>"},{"location":"spec/#12-action","title":"1.2 Action","text":"<p>An action is a stateful process representing a unit of interactive intent (e.g., attack, dodge, block).</p> <p>Each action MUST define: - a current phase value - a phase progression rule - one or more phase windows - explicit transition semantics</p> <p>Only actions are permitted to own or advance phase.</p>"},{"location":"spec/#13-phase-window","title":"1.3 Phase Window","text":"<p>A phase window is a named subset of the phase space.</p> <p>Formally:</p> <p>Window \u2286 \u2124\u208d\u2082\u2084\u208e</p> <p>Phase windows encode gameplay semantics including but not limited to: - damage authority - invulnerability - cancel eligibility - vulnerability or recovery - transition availability</p> <p>All gameplay-relevant semantics MUST be expressible through phase windows.</p>"},{"location":"spec/#2-phase-authority","title":"2. Phase Authority","text":""},{"location":"spec/#21-authoritative-coordinate","title":"2.1 Authoritative Coordinate","text":"<p>Phase is the sole authoritative coordinate for: - action progression - interaction adjudication - cancel and transition eligibility - deterministic resolution across subsystems</p> <p>Time MUST NOT be used as an authoritative input for gameplay semantics.</p>"},{"location":"spec/#22-derived-time","title":"2.2 Derived Time","text":"<p>Elapsed time MAY be used for: - rendering - animation sampling - interpolation - audio playback</p> <p>Derived time MUST NOT influence: - phase progression - phase window membership - interaction outcomes</p>"},{"location":"spec/#3-phase-progression","title":"3. Phase Progression","text":""},{"location":"spec/#31-discrete-advancement","title":"3.1 Discrete Advancement","text":"<p>Phase MUST advance discretely in integer steps.</p> <p>Valid advancement:</p> <p>phase_next = (phase_current + k) mod 24</p> <p>where <code>k \u2265 0</code> is an integer.</p> <p>Fractional advancement is forbidden.</p>"},{"location":"spec/#32-determinism","title":"3.2 Determinism","text":"<p>Given identical inputs, phase progression MUST be deterministic.</p> <p>Phase advancement rules MUST: - be integer-based - avoid floating-point dependence - be invariant across platforms</p>"},{"location":"spec/#4-action-lifecycle-semantics","title":"4. Action Lifecycle Semantics","text":""},{"location":"spec/#41-lifecycle-completion","title":"4.1 Lifecycle Completion","text":"<p>Each action MUST define its behavior upon phase wrap:</p> <ul> <li>TERMINATE \u2014 action ends and yields control</li> <li>LOOP \u2014 action repeats its phase cycle</li> <li>CLAMP \u2014 phase is held at a terminal value</li> </ul> <p>Undefined wrap behavior is forbidden.</p>"},{"location":"spec/#42-transitions","title":"4.2 Transitions","text":"<p>Actions MAY define transitions to other actions.</p> <p>Transitions MUST be: - phase-gated - explicitly defined - deterministic</p> <p>Implicit or time-based transitions are forbidden.</p>"},{"location":"spec/#5-interaction-adjudication","title":"5. Interaction Adjudication","text":""},{"location":"spec/#51-window-based-resolution","title":"5.1 Window-Based Resolution","text":"<p>All interactions between entities MUST be resolved by evaluating: - the interacting actions - their current phases - their active phase windows</p> <p>No interaction outcome may depend on: - animation state - frame order - wall-clock time - network arrival order</p>"},{"location":"spec/#52-precedence","title":"5.2 Precedence","text":"<p>When multiple phase windows apply, a deterministic precedence rule MUST be defined.</p> <p>Typical precedence (example): 1. Invulnerability 2. Perfect defense 3. Mitigating defense 4. Hit</p> <p>The precedence ordering MUST be explicit and stable.</p>"},{"location":"spec/#6-cancellation-semantics","title":"6. Cancellation Semantics","text":""},{"location":"spec/#61-cancel-eligibility","title":"6.1 Cancel Eligibility","text":"<p>Cancels MUST be defined as phase windows.</p> <p>An action MAY only cancel into another action if: - the current phase lies within a defined cancel window - the target action is explicitly permitted</p>"},{"location":"spec/#62-buffered-inputs","title":"6.2 Buffered Inputs","text":"<p>Input buffering MAY be supported.</p> <p>Buffered inputs MUST: - be consumed only when entering a valid phase window - resolve deterministically - not bypass phase restrictions</p>"},{"location":"spec/#7-subsystem-interaction","title":"7. Subsystem Interaction","text":""},{"location":"spec/#71-subscription-model","title":"7.1 Subscription Model","text":"<p>Subsystems (animation, AI, VFX, audio, networking) MUST subscribe to phase.</p> <p>Subsystems MUST NOT: - infer action stage from time - advance phase independently - override phase authority</p>"},{"location":"spec/#72-presentation","title":"7.2 Presentation","text":"<p>Presentation systems MAY derive visuals from phase.</p> <p>Presentation MUST NOT influence gameplay outcomes.</p>"},{"location":"spec/#8-networking-and-replication","title":"8. Networking and Replication","text":""},{"location":"spec/#81-replicated-state","title":"8.1 Replicated State","text":"<p>A networked PCAM-24 system MUST replicate: - action identity - phase value - start-captured parameters</p> <p>Elapsed time MUST NOT be replicated as authoritative state.</p>"},{"location":"spec/#82-reconciliation","title":"8.2 Reconciliation","text":"<p>Phase reconciliation MUST be: - discrete - deterministic - bounded in phase units</p> <p>Phase snapping is permitted. Phase interpolation for authority is forbidden.</p>"},{"location":"spec/#9-error-handling","title":"9. Error Handling","text":""},{"location":"spec/#91-invalid-states","title":"9.1 Invalid States","text":"<p>The following are invalid: - fractional phase values - undefined phase windows - time-based adjudication - implicit transitions</p> <p>Implementations MUST fail fast or correct deterministically.</p>"},{"location":"spec/#10-conformance","title":"10. Conformance","text":"<p>An implementation conforms to PCAM-24 if and only if:</p> <ul> <li>phase is the sole authoritative coordinate</li> <li>all gameplay semantics are phase-window-based</li> <li>phase progression is discrete and deterministic</li> <li>subsystems subscribe without inference</li> <li>time is strictly derived</li> </ul>"},{"location":"spec/#11-versioning","title":"11. Versioning","text":"<p>This document defines PCAM-24 v1.0.</p> <p>Future revisions MUST: - preserve phase authority - remain backward-compatible unless explicitly stated</p>"},{"location":"spec/#12-final-statement","title":"12. Final Statement","text":"<p>PCAM-24 defines a model in which stage, not time, is the source of truth.</p> <p>This specification is intentionally minimal. It defines what MUST be true, not how it must be implemented. EOF</p>"},{"location":"whitepaper/","title":"PCAM-24: A Phase-Centric Action Model for Deterministic Interactive Simulation","text":""},{"location":"whitepaper/#abstract","title":"Abstract","text":"<p>This paper introduces PCAM-24 (Phase-Centric Action Model), a simulation model in which discrete phase\u2014rather than continuous time\u2014is the authoritative coordinate for action progression, interaction adjudication, and cross-system synchronization. PCAM-24 defines actions as cyclic phase processes within a fixed modular phase space and expresses all gameplay-relevant semantics (e.g., hit windows, invulnerability, cancels, transitions) as phase membership.</p> <p>By elevating phase to a first-class primitive, PCAM-24 eliminates timing inference between subsystems, simplifies deterministic networking, and provides a shared semantic language for animation, combat, AI, and tooling. The model is particularly suited to real-time interactive simulations where perceived fairness, explainability, and determinism are critical.</p>"},{"location":"whitepaper/#1-introduction","title":"1. Introduction","text":"<p>Modern interactive simulations\u2014especially games\u2014coordinate multiple subsystems that each operate on their own notion of time. Animation systems advance clip time, combat systems evaluate frame-based windows, AI systems reason in ticks, and networking layers reconcile wall-clock deltas. While effective in practice, this fragmentation produces systemic problems:</p> <ul> <li>Desynchronization between animation and gameplay outcomes.</li> <li>Brittle timing logic expressed in floats or frame counts.</li> <li>Ambiguous interaction adjudication under latency.</li> <li>Difficulty explaining or debugging why a given outcome occurred.</li> </ul> <p>PCAM-24 proposes a different foundation: replace time as the primary semantic coordinate with discrete phase. Rather than asking \"when did something happen?\", PCAM-24 asks \"what stage of the action is occurring?\"</p>"},{"location":"whitepaper/#2-core-concept","title":"2. Core Concept","text":""},{"location":"whitepaper/#21-phase-space","title":"2.1 Phase Space","text":"<p>PCAM-24 defines a fixed, cyclic phase space:</p> \\[\\text{Phase} \\in \\mathbb{Z}_{24} = \\{0, 1, \\dots, 23\\}\\] <p>Phase advances discretely and wraps modulo 24. Phase progression is monotonic and integer-valued; partial phases and fractional authority are disallowed.</p> <p>The choice of 24 phases reflects a balance between expressive resolution and cognitive tractability. It provides sufficient granularity to model nuanced action stages while remaining small enough to reason about as a complete cycle.</p>"},{"location":"whitepaper/#22-actions","title":"2.2 Actions","text":"<p>An action is the atomic unit of interactive intent (e.g., attack, dodge, parry, block). Each action owns:</p> <ul> <li>A current phase value.</li> <li>A phase progression rule.</li> <li>A set of named phase windows.</li> <li>Deterministic transition rules.</li> </ul> <p>An action is not measured in seconds. It progresses through semantic stages defined by phase.</p>"},{"location":"whitepaper/#3-phase-windows-and-semantics","title":"3. Phase Windows and Semantics","text":"<p>A phase window is a named subset of the phase space. Formally, each window is a set:</p> \\[W \\subseteq \\mathbb{Z}_{24}\\] <p>Examples include:</p> <ul> <li>ACTIVE: Phases during which an attack can deal damage.</li> <li>INVULN: Phases during which damage is negated.</li> <li>PARRY_PERFECT: Phases during which a parry fully succeeds.</li> <li>RECOVERY: Phases during which vulnerability or restrictions apply.</li> </ul> <p>All authoritative gameplay decisions are reduced to window membership tests. Time, frame count, or animation normalized time are never authoritative inputs.</p>"},{"location":"whitepaper/#4-phase-authority","title":"4. Phase Authority","text":"<p>PCAM-24 enforces several non-negotiable axioms:</p> <ul> <li>Phase is authoritative: Phase is the sole coordinate for ordering, gating, and adjudication of actions and interactions.</li> <li>Discrete semantics: All gameplay-relevant logic must be expressible as phase membership or phase-gated transitions.</li> <li>Monotonic progression: Phase advances monotonically on the cyclic ring. Rewinds are prohibited; corrections occur by snapping phase or restarting actions.</li> <li>Subsystem subscription: Subsystems (animation, combat, AI, VFX, audio, UI) observe phase and windows but do not advance or reinterpret them.</li> <li>Interaction resolution by phase: Cross-entity interactions are resolved exclusively through phase-defined rules and explicit precedence.</li> </ul>"},{"location":"whitepaper/#5-action-lifecycles","title":"5. Action Lifecycles","text":"<p>PCAM-24 categorizes actions by lifecycle semantics:</p> <ul> <li>Impulse actions (e.g., melee attack): Progress once through the phase cycle and terminate.</li> <li>Sustained actions (e.g., block hold): Loop through phases while input is maintained.</li> <li>Reactive actions (e.g., parry): Feature narrow success windows and defined failure recovery.</li> <li>Evasive actions (e.g., dodge roll): Include invulnerability or mitigation windows and phase-driven movement.</li> </ul> <p>Each action must explicitly define what phase wrap means (termination, loop, or clamp), preventing ambiguous lifecycle behavior.</p>"},{"location":"whitepaper/#6-cancels-transitions-and-buffering","title":"6. Cancels, Transitions, and Buffering","text":"<p>Action transitions\u2014such as cancels, combos, or state changes\u2014are phase-gated:</p> <ol> <li>Cancels are allowed only within defined windows.</li> <li>Inputs may be buffered and consumed deterministically when entering valid windows.</li> <li>If multiple transitions are eligible simultaneously, a deterministic priority rule resolves the outcome.</li> </ol> <p>This replaces ad-hoc frame windows and timing constants with inspectable, authorable phase logic.</p>"},{"location":"whitepaper/#7-interaction-adjudication","title":"7. Interaction Adjudication","text":"<p>PCAM-24 requires explicit precedence for contested interactions. A canonical ordering is:</p> <ol> <li>Evasion (e.g., invulnerability windows)</li> <li>Perfect defense (e.g., parry)</li> <li>Mitigating defense (e.g., block)</li> <li>Hit (full effect)</li> </ol> <p>When an attack intersects a defender, the outcome is determined by the defender\u2019s current action and phase windows\u2014not by animation timing, render order, or wall-clock arrival.</p> <p>This makes outcomes deterministic, explainable, and consistent under network conditions.</p>"},{"location":"whitepaper/#8-networking-and-determinism","title":"8. Networking and Determinism","text":"<p>PCAM-24 is inherently network-friendly because it replicates phase, not time.</p> <ul> <li>Network replication transmits action identifiers, phase values, and any start-captured parameters.</li> <li>Clients may predict locally by advancing phase using the same rules.</li> <li>Reconciliation is performed by snapping phase to authoritative values, optionally with bounded grace policies expressed in phase units.</li> </ul> <p>No reconstruction of exact elapsed time is required.</p>"},{"location":"whitepaper/#9-tooling-and-explainability","title":"9. Tooling and Explainability","text":"<p>A PCAM-24 system is only viable if its semantics are visible. Tooling must allow inspection of:</p> <ul> <li>Current action and phase.</li> <li>Active phase windows.</li> <li>Eligible transitions and their conditions.</li> <li>Recent interaction outcomes.</li> </ul> <p>By making phase explicit, PCAM-24 transforms timing bugs from opaque artifacts into inspectable state.</p>"},{"location":"whitepaper/#10-benefits-and-implications","title":"10. Benefits and Implications","text":"<p>PCAM-24 offers several advantages over time-centric models:</p> <ul> <li>Consistency: Animation, combat, AI, and networking share a single semantic clock.</li> <li>Determinism: Discrete phase eliminates floating-point drift and ambiguous comparisons.</li> <li>Explainability: Outcomes can be justified directly by phase membership.</li> <li>Authorability: Designers reason in semantic stages rather than frames or milliseconds.</li> <li>Extensibility: New systems subscribe to phase without redefining timing logic.</li> </ul>"},{"location":"whitepaper/#11-non-goals","title":"11. Non-Goals","text":"<p>PCAM-24 does not attempt to:</p> <ul> <li>Replace continuous physics solvers.</li> <li>Reform civil or real-world timekeeping.</li> <li>Mandate a specific engine or update loop.</li> <li>Eliminate all uses of real time in rendering or presentation.</li> </ul> <p>It defines only what is authoritative for interaction semantics.</p>"},{"location":"whitepaper/#12-conclusion","title":"12. Conclusion","text":"<p>PCAM-24 reframes interactive simulation timing from a question of when to a question of what stage. By elevating discrete phase to a first-class primitive, it provides a unifying semantic substrate across subsystems that are traditionally decoupled and inference-driven. The result is a model that is deterministic, inspectable, and aligned with how players perceive actions\u2014not as durations, but as stages of intent.</p> <p>PCAM-24 is not an optimization of existing timing systems. It is a replacement of their underlying assumption.</p>"},{"location":"why-not-time/","title":"Why Phase, Not Time?","text":"<p>This document explains why PCAM-24 replaces time as the authoritative coordinate for interactive action semantics, rather than attempting to refine or optimize time-based systems.</p> <p>The goal is not to claim that time-based models are \u201cwrong,\u201d but to show where they break down and why phase offers a cleaner, more reliable alternative.</p>"},{"location":"why-not-time/#the-core-problem-with-time-based-authority","title":"The Core Problem with Time-Based Authority","text":"<p>Most interactive systems treat time as the primary ordering mechanism:</p> <ul> <li>seconds elapsed</li> <li>frames passed</li> <li>normalized animation time</li> <li>cooldown timers</li> <li>wall-clock deltas (network)</li> </ul> <p>However, players do not perceive actions in time.</p> <p>They perceive: - wind-up - commitment - impact - recovery - vulnerability</p> <p>These are stages, not durations.</p> <p>Time-based systems must infer stage from time, which introduces ambiguity.</p>"},{"location":"why-not-time/#common-time-based-approaches-and-their-limits","title":"Common Time-Based Approaches (and Their Limits)","text":""},{"location":"why-not-time/#1-frame-based-combat-logic","title":"1. Frame-Based Combat Logic","text":"<p>Approach - Hits, parries, and cancels are defined in animation frames - Example: \u201cActive on frames 12\u201316\u201d</p> <p>Problems - Frame counts depend on playback speed - FPS changes alter behavior - Online corrections create disagreement about which frame occurred - Designers reason in frames, players do not</p> <p>Frame data works, but it is fragile and difficult to generalize across systems.</p>"},{"location":"why-not-time/#2-normalized-time-0010","title":"2. Normalized Time (0.0\u20131.0)","text":"<p>Approach - Gameplay logic tied to normalized animation progress - Example: \u201cHit at 0.45\u20130.55 of the clip\u201d</p> <p>Problems - Assumes animation is the authority - Blending and retargeting distort meaning - Different clips encode different semantics - Normalized time answers how far, not what stage</p> <p>Normalized time hides semantics behind floating-point comparisons.</p>"},{"location":"why-not-time/#3-timer-cooldown-systems","title":"3. Timer / Cooldown Systems","text":"<p>Approach - Explicit durations in seconds - Example: \u201cInvulnerable for 0.3s\u201d</p> <p>Problems - Sensitive to tick rate and jitter - Requires tuning per platform - Difficult to align with animation and AI - Hard to explain under latency</p> <p>Timers answer when something ends, not what is happening now.</p>"},{"location":"why-not-time/#4-fixed-timestep-simulation","title":"4. Fixed Timestep Simulation","text":"<p>Approach - Fixed delta time for gameplay - Rendering interpolated separately</p> <p>Problems - Still requires time-based windows - Does not solve semantic alignment - Subsystems still infer stage independently</p> <p>Fixed timestep improves stability but does not address semantic fragmentation.</p>"},{"location":"why-not-time/#the-fundamental-issue-inference","title":"The Fundamental Issue: Inference","text":"<p>Time-based systems require every subsystem to infer action stage independently:</p> <ul> <li>Animation infers from clip time</li> <li>Combat infers from timers</li> <li>AI infers from state flags</li> <li>Networking infers from arrival order</li> </ul> <p>These inferences drift.</p> <p>PCAM-24 removes inference entirely.</p>"},{"location":"why-not-time/#phase-as-a-semantic-coordinate","title":"Phase as a Semantic Coordinate","text":"<p>PCAM-24 introduces phase as a shared, discrete coordinate representing where an action is in its lifecycle.</p> <p>Key properties:</p> <ul> <li>Phase is discrete, not continuous</li> <li>Phase is cyclic and bounded</li> <li>Phase directly encodes semantics</li> <li>Phase is inspectable and explainable</li> </ul> <p>Instead of asking:</p> <p>\u201cHow much time has passed?\u201d</p> <p>PCAM-24 asks:</p> <p>\u201cWhich phase window is active?\u201d</p>"},{"location":"why-not-time/#why-discrete-phase-works-better","title":"Why Discrete Phase Works Better","text":""},{"location":"why-not-time/#1-phase-matches-human-reasoning","title":"1. Phase Matches Human Reasoning","text":"<p>Designers and players think in stages: - \u201cearly\u201d - \u201cactive\u201d - \u201clate\u201d - \u201crecovery\u201d</p> <p>Phase encodes these stages directly.</p>"},{"location":"why-not-time/#2-phase-eliminates-floating-point-ambiguity","title":"2. Phase Eliminates Floating-Point Ambiguity","text":"<ul> <li>No epsilon comparisons</li> <li>No drift</li> <li>No frame-rate dependence</li> </ul> <p>Membership in a phase window is unambiguous.</p>"},{"location":"why-not-time/#3-phase-unifies-subsystems","title":"3. Phase Unifies Subsystems","text":"<p>Animation, combat, AI, VFX, audio, and networking all reference the same phase value.</p> <p>No subsystem needs its own clock.</p>"},{"location":"why-not-time/#4-phase-makes-networking-explainable","title":"4. Phase Makes Networking Explainable","text":"<p>Instead of:</p> <p>\u201cLatency caused the hit to register late\u201d</p> <p>You get:</p> <p>\u201cThe defender was in phase 9, not phase 10\u201d</p> <p>This is debuggable and fair.</p>"},{"location":"why-not-time/#why-24-phases","title":"Why 24 Phases?","text":"<p>PCAM-24 uses a fixed 24-phase cycle because it offers:</p> <ul> <li>Enough resolution for nuanced actions</li> <li>Clean subdivision (2, 3, 4, 6, 8, 12)</li> <li>A full action cycle without overfitting</li> <li>Cognitive tractability for designers</li> </ul> <p>The specific number is less important than the principle: phase must be discrete, bounded, and semantic.</p>"},{"location":"why-not-time/#why-not-just-frames","title":"Why Not \u201cJust Frames\u201d?","text":"<p>Frames are: - hardware- and framerate-dependent - presentation-driven - unsuitable as a shared semantic language</p> <p>Phase is: - engine-agnostic - simulation-authoritative - presentation-independent</p>"},{"location":"why-not-time/#phase-does-not-eliminate-time","title":"Phase Does Not Eliminate Time","text":"<p>PCAM-24 does not eliminate time entirely.</p> <p>Time still exists for: - rendering - interpolation - animation sampling - audio playback</p> <p>However, time becomes a derived view, not the authority.</p> <p>Phase decides what is happening; time decides how it is shown.</p>"},{"location":"why-not-time/#summary","title":"Summary","text":"<p>Time-based systems answer:</p> <p>\u201cWhen did something occur?\u201d</p> <p>PCAM-24 answers:</p> <p>\u201cWhat stage is the action in?\u201d</p> <p>For interactive simulations\u2014where fairness, feel, and explainability matter more than absolute timestamps\u2014stage is the more meaningful truth.</p> <p>PCAM-24 replaces timing inference with explicit semantics.</p> <p>Phase is not an optimization of time. It is a replacement for time where meaning matters.</p>"}]}